

ovs-vsctl add-port br-ex test
ovs-vsctl add-port br-provider test2
ovs-vsctl set interface test type=patch options:peer=test2
ovs-vsctl set interface test2 type=patch options:peer=test










HOST_CALICO_DEV=eth0
HOST_CALICO_IP=$(ip -f inet -o addr show $HOST_CALICO_DEV|cut -d\  -f 7 | cut -d/ -f 1)



HOST_ETCD_DEV=eth0
HOST_ETCD_IP=$(ip -f inet -o addr show $HOST_ETCD_DEV|cut -d\  -f 7 | cut -d/ -f 1)

HOST_KUBE_DEV=eth0
HOST_KUBE_IP=$(ip -f inet -o addr show $HOST_KUBE_DEV|cut -d\  -f 7 | cut -d/ -f 1)



(

yum install -y docker etcd bridge-utils crudini bind-utils ipa-client


hostnamectl set-hostname centos1.harboros.net
(
curl -L https://github.com/docker/compose/releases/download/1.6.2/run.sh > /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose

curl -L http://www.projectcalico.org/builds/calicoctl > /usr/local/bin/calicoctl
chmod +x /usr/local/bin/calicoctl


)
)

crudini --set /etc/NetworkManager/NetworkManager.conf main dns none
systemctl restart NetworkManager


cat > /usr/local/bin/docker-bootstrap-daemon <<EOF
#!/bin/bash
set -e
PATH=/usr/local/bin:${PATH}

ip link set dev docker down || true
brctl delbr docker || true
brctl addbr docker || true
ip addr add 172.17.42.1/16 dev docker || true
ip link set dev docker mtu 1500 || true
ip link set dev docker up || true

exec /usr/bin/docker-current daemon \
        --exec-opt native.cgroupdriver=systemd \\
        -H unix:///var/run/docker-bootstrap.sock \\
        -p /var/run/docker-bootstrap.pid \\
        --graph=/var/lib/docker-bootstrap \\
        --bridge=docker \\
        --dns="8.8.8.8" \\
        --mtu=1500 \\
        --fixed-cidr=172.17.42.1/16 \\
        --ip=172.17.42.1 \\
        --userland-proxy=false \\
        --storage-driver overlay
EOF
chmod +x /usr/local/bin/docker-bootstrap-daemon

cat > /etc/systemd/system/docker-bootstrap.service <<EOF
[Unit]
Description=Docker Bootstrap Application Container Engine
Documentation=https://docs.docker.com
After=network-online.target cloud-init.service chronyd.service
Wants=network-online.target

[Service]
Type=notify
ExecStart=/usr/local/bin/docker-bootstrap-daemon
MountFlags=slave
LimitNOFILE=1048576
LimitNPROC=1048576
LimitCORE=infinity
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF


cat > /usr/bin/docker-bootstrap <<EOF
#!/bin/bash
docker -H unix:///var/run/docker-bootstrap.sock "\$@"
EOF
chmod +x /usr/bin/docker-bootstrap



systemctl daemon-reload
systemctl restart docker-bootstrap

docker-bootstrap info



touch /etc/master-node

cat > /usr/local/bin/skydns-daemon <<EOF
#!/bin/bash
HOST_ETCD_DEV=eth0
HOST_ETCD_IP=\$(ip -f inet -o addr show \$HOST_ETCD_DEV|cut -d\  -f 7 | cut -d/ -f 1)

if [ -f /etc/master-node ]
  then
    if etcdctl ls ; then
        echo "Command succeeded"
    else
        echo "Command failed"
        HOST_ETCD_IP=\$(ip -f inet -o addr show \$HOST_ETCD_DEV|cut -d\  -f 7 | cut -d/ -f 1)
        docker-bootstrap stop bootstrap-etcd || true
        docker-bootstrap rm bootstrap-etcd || true
        docker-bootstrap run -d \
        --name bootstrap-etcd \
        --net=host \
        -v /var/etcd:/var/etcd \
        docker.io/port/system-etcd:latest \
        etcd \
        --name=\$(hostname -f) \
        --data-dir=/var/etcd \
        --listen-client-urls=http://localhost:2379,http://\${HOST_ETCD_IP}:4001 \
        --listen-peer-urls=http://\${HOST_ETCD_IP}:7001 \
        --advertise-client-urls=http://\$(hostname -f):4001
        (
        until dig skydns.local @172.17.42.1
        do
          echo "Waiting for SKYDNS to respond"
          sleep 5
        done
        docker-bootstrap stop bootstrap-etcd || true
        docker-bootstrap rm bootstrap-etcd || true
        )&
    fi
fi

docker-bootstrap stop skydns || true
docker-bootstrap kill skydns || true
docker-bootstrap rm -v skydns || true
docker-bootstrap run \
    --name skydns \
    -d \
    --net=host \
    -p 172.17.42.1:53:53 \
    docker.io/port/system-skydns:latest \
        -addr="172.17.42.1:53" \
        -nameservers="8.8.8.8:53,8.8.4.4:53" \
        -machines="http://\${HOST_ETCD_IP}:4001"

until dig skydns.local @172.17.42.1
do
  echo "Waiting for SKYDNS to respond"
  sleep 2
done
echo "nameserver 172.17.42.1" > /etc/resolv.conf
echo "# Generated by HarborOS" >> /etc/resolv.conf
EOF
chmod +x /usr/local/bin/skydns-daemon

cat > /etc/systemd/system/skydns.service <<EOF
[Unit]
Description=Skydns per-node agent
Requires=docker-bootstrap.service
After=docker-bootstrap.service
Before=docker.service flannel.service

[Service]
User=root
ExecStartPre=/usr/local/bin/skydns-daemon
ExecStart=/usr/bin/etcdctl watch /skydns/config
Restart=always
RestartSec=2

[Install]
WantedBy=multi-user.target
EOF



systemctl daemon-reload
systemctl restart skydns



cat > /etc/systemd/system/openvswitch.service <<EOF
[Unit]
Description=OpenvSwitch
After=network.target docker-bootstrap.service
Requires=network.target docker-bootstrap.service

[Service]
StandardOutput=null
TimeoutStartSec=0
Type=simple
ExecStartPre=/usr/sbin/modprobe openvswitch
ExecStartPre=-/usr/bin/docker-bootstrap pull docker.io/port/system-ovs:latest

ExecStartPre=-/usr/bin/docker-bootstrap stop ovs-install
ExecStartPre=-/usr/bin/docker-bootstrap kill ovs-install
ExecStartPre=-/usr/bin/docker-bootstrap rm ovs-install
ExecStartPre=/usr/bin/docker-bootstrap run \
              --name ovs-install \
              --net=host \
              -v /:/host \
               docker.io/port/system-ovs:latest harbor-install
ExecStartPre=-/usr/bin/docker-bootstrap stop ovs-install
ExecStartPre=-/usr/bin/docker-bootstrap kill ovs-install
ExecStartPre=-/usr/bin/docker-bootstrap rm ovs-install

ExecStartPre=-/usr/bin/docker-bootstrap stop ovs
ExecStartPre=-/usr/bin/docker-bootstrap kill ovs
ExecStartPre=-/usr/bin/docker-bootstrap rm ovs
ExecStartPre=/usr/bin/docker-bootstrap run \
              --name ovs \
              --restart=always \
              -d \
              --net=host \
              --privileged \
              --cap-add NET_ADMIN \
              -v /dev/net:/dev/net \
              -v /var/run/openvswitch:/var/run/openvswitch \
              -v /var/lib/openvswitch:/var/lib/openvswitch \
               docker.io/port/system-ovs:latest
ExecStart=/usr/bin/docker-bootstrap wait ovs

Restart=on-failure
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl restart openvswitch












cat > /usr/local/bin/flannel-daemon <<EOF
#!/bin/bash
HOST_FLANNEL_PUBLIC_DEV=eth0
HOST_ETCD_DEV=eth0

if [ -f /etc/master-node ]
  then
    HOST_ETCD_IP=\$(ip -f inet -o addr show \$HOST_ETCD_DEV|cut -d\  -f 7 | cut -d/ -f 1)
    rm -rf /var/run/flannel/networks
    docker-bootstrap stop bootstrap-etcd || true
    docker-bootstrap rm bootstrap-etcd || true
    docker-bootstrap run -d \
    --name bootstrap-etcd \
    --net=host \
    -v /var/etcd:/var/etcd \
    docker.io/port/system-etcd:latest \
    etcd \
    --name=\$(hostname -f) \
    --data-dir=/var/etcd \
    --listen-client-urls=http://localhost:2379,http://\${HOST_ETCD_IP}:4001 \
    --listen-peer-urls=http://\${HOST_ETCD_IP}:7001 \
    --advertise-client-urls=http://\${HOST_ETCD_IP}:4001

fi


HOST_FLANNEL_PUBLIC_IP=\$(ip -f inet -o addr show \$HOST_FLANNEL_PUBLIC_DEV|cut -d\  -f 7 | cut -d/ -f 1)
docker-bootstrap stop flannel || true
docker-bootstrap kill flannel || true
docker-bootstrap rm -v flannel || true
docker-bootstrap run \
    --name flannel \
    --net=host \
    --privileged \
    -d \
    -v /dev/net:/dev/net:rw \
    -v /run/flannel:/run/flannel:rw \
    docker.io/port/system-flannel:latest \
      /opt/bin/flanneld \
      --ip-masq=true \
      --alsologtostderr=true \
      --iface=eth0 \
      --etcd-prefix="/flannel/network" \
      --etcd-endpoints="http://\$(hostname -f):4001" \
      --public-ip="\${HOST_FLANNEL_PUBLIC_IP}" \
      -networks="core,wan"

if [ -f /etc/master-node ]
  then
    until etcdctl set /flannel/network/core/config '{ "Network": "10.96.0.0/15", "Backend": { "Type": "host-gw" } }'
    do
         echo "Waiting for ETCD"
         sleep 5
    done
    until etcdctl set /flannel/network/wan/config '{ "Network": "10.98.0.0/16", "Backend": { "Type": "vxlan", "VNI": 1 } }'
    do
         echo "Waiting for ETCD"
         sleep 5
    done
    until [ -f /var/run/flannel/networks/core.env ]
    do
         echo "Waiting for Flannel subnet"
         sleep 5
    done
    docker-bootstrap stop bootstrap-etcd || true
    docker-bootstrap rm bootstrap-etcd || true
fi


EOF
chmod +x /usr/local/bin/flannel-daemon





cat > /etc/systemd/system/flannel.service <<EOF
[Unit]
Description=Flannel per-node agent
Requires=docker-bootstrap.service
After=docker-bootstrap.service
Before=docker.service

[Service]
User=root
ExecStartPre=/usr/local/bin/flannel-daemon
ExecStart=/usr/bin/docker-bootstrap wait flannel
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF



systemctl daemon-reload
systemctl restart flannel





















cat > /usr/local/bin/docker-wan-daemon <<EOF
#!/bin/bash
set -e
PATH=/usr/local/bin:${PATH}
source /var/run/flannel/networks/wan.env

HOST_ETCD_DEV=eth0
HOST_ETCD_IP=\$(ip -f inet -o addr show \$HOST_ETCD_DEV|cut -d\  -f 7 | cut -d/ -f 1)


ip link set dev docker1 down || true
brctl delbr docker1 || true
brctl addbr docker1 || true
ip addr add \${FLANNEL_SUBNET} dev docker1 || true
ip link set dev docker1 mtu ${FLANNEL_MTU} || true
ip link set dev docker1 up || true


HOST_DOCKER_ADMIN_IP=\$(echo \$FLANNEL_SUBNET | awk -F '/' '{print \$1}')
exec /usr/bin/docker-current daemon \
        --exec-opt native.cgroupdriver=systemd \\
        -H unix:///var/run/docker-wan.sock \\
        -H tcp://\${HOST_DOCKER_ADMIN_IP}:2375 \\
        -p /var/run/docker-wan.pid \\
        --graph=/var/lib/docker-wan \\
        --bridge=docker1 \\
        --dns=172.17.42.1 \\
        --mtu=\${FLANNEL_MTU} \\
        --fixed-cidr=\${FLANNEL_SUBNET} \\
        --userland-proxy=false \\
        --storage-driver overlay \\
        --cluster-advertise \${HOST_DOCKER_ADMIN_IP}:2375 \\
        --cluster-store etcd://\${HOST_ETCD_IP}:4001
EOF
chmod +x /usr/local/bin/docker-wan-daemon

cat > /etc/systemd/system/docker-wan.service <<EOF
[Unit]
Description=Docker Wan Application Container Engine
Documentation=https://docs.docker.com
After=network-online.target cloud-init.service chronyd.service flannel.service
Requires=flannel.service
Wants=network-online.target

[Service]
Type=notify
ExecStart=/usr/local/bin/docker-wan-daemon
MountFlags=slave
LimitNOFILE=1048576
LimitNPROC=1048576
LimitCORE=infinity
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF


cat > /usr/bin/docker-wan <<EOF
#!/bin/bash
docker -H unix:///var/run/docker-wan.sock "\$@"
EOF
chmod +x /usr/bin/docker-wan


systemctl daemon-reload
systemctl restart docker-wan












cat > /usr/local/bin/docker-daemon <<EOF
#!/bin/bash
set -e
PATH=/usr/local/bin:${PATH}
source /var/run/flannel/networks/core.env

docker-bootstrap stop bootstrap-etcd || true
docker-bootstrap kill bootstrap-etcd || true
docker-bootstrap rm bootstrap-etcd || true

ip link set docker0 down || true
brctl delbr docker0 || true

exec /usr/bin/docker-current daemon \
        --exec-opt native.cgroupdriver=systemd \\
        -H unix:///var/run/docker.sock \\
        -p /var/run/docker.pid \\
        --graph=/var/lib/docker \\
        --dns=172.17.42.1 \\
        --bip=\${FLANNEL_SUBNET} \\
        --mtu=\${FLANNEL_MTU} \\
        --userland-proxy=false \\
        --storage-driver overlay
EOF
chmod +x /usr/local/bin/docker-daemon



cat > /etc/systemd/system/docker.service <<EOF
[Unit]
Description=Docker Application Container Engine
Documentation=https://docs.docker.com
After=network-online.target cloud-init.service chronyd.service flannel.service docker-wan.service
Requires=flannel.service
Wants=network-online.target

[Service]
Type=notify
ExecStart=/usr/local/bin/docker-daemon
MountFlags=slave
LimitNOFILE=1048576
LimitNPROC=1048576
LimitCORE=infinity
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl restart docker




(
mkdir -p /opt/cni/bin
curl -L https://github.com/projectcalico/calico-cni/releases/download/v1.3.1/calico > /opt/cni/bin/calico
chmod +x /opt/cni/bin/calico
curl -L https://github.com/projectcalico/calico-cni/releases/download/v1.3.1/calico-ipam > /opt/cni/bin/calico-ipam
chmod +x /opt/cni/bin/calico-ipam
)


mkdir -p /etc/cni/net.d
cat > /etc/cni/net.d/10-calico.conf <<EOF
{
    "name": "calico-k8s-network",
    "type": "calico",
    "etcd_authority": "${HOST_ETCD_IP}:4001",
    "log_level": "info",
    "ipam": {
        "type": "calico-ipam"
    }
}
EOF



mkdir -p /etc/kubernetes
cat > /etc/kubernetes/docker-compose.yml <<EOF
version: "2"
services:
  kubelet:
    container_name: "kubelet"
    image: "docker.io/port/system-kube:latest"
    restart: "always"
    privileged: true
    network_mode: "host"
    pid: "host"
    volumes:
      - "/sys:/sys:ro"
      - "/var/run:/var/run:rw"
      - "/:/rootfs:ro"
      - "/dev:/dev:rw"
      - "/etc/cni/net.d:/etc/cni/net.d:rw"
      - "/var/lib/docker:/var/lib/docker:rw"
      - "/var/lib/kubelet:/var/lib/kubelet:rw"
      - "/etc/os-release:/etc/os-release:ro"
      - "/etc/kubernetes/manifests:/etc/kubernetes/manifests:ro"
    command:
      - "/hyperkube"
      - "kubelet"
      - "--v=3"
      - "--address=0.0.0.0"
      - "--allow-privileged=true"
      - "--cluster-dns=172.17.42.1"
      - "--cluster-domain=cluster.local"
      - "--config=/etc/kubernetes/manifests"
      - "--hostname-override=${HOST_CALICO_IP}"
      - "--api-servers=http://${HOST_KUBE_IP}:8080"
      - "--logtostderr=true"
      - "--docker=\"unix:///var/run/docker.sock\""
      - "--network-plugin-dir=/etc/cni/net.d"
      - "--network-plugin=cni"
      - "--pod-infra-container-image=docker.io/port/pause:latest"
EOF






cat > /usr/local/bin/kubelet-daemon-start <<EOF
#!/bin/bash
set -e
PATH=/usr/local/bin:${PATH}
cd /etc/kubernetes
/usr/bin/docker-compose --project-name kubernetes down || true
/usr/bin/docker-compose --project-name kubernetes up -d
EOF
chmod +x /usr/local/bin/kubelet-daemon-start

cat > /usr/local/bin/kubelet-daemon-monitor <<EOF
#!/bin/bash
set -e
PATH=/usr/local/bin:${PATH}
cd /etc/kubernetes
/usr/bin/docker wait \$(/usr/bin/docker-compose --project-name kubernetes ps -q | head -n 1)
EOF
chmod +x /usr/local/bin/kubelet-daemon-monitor

cat > /usr/local/bin/kubelet-daemon-stop <<EOF
#!/bin/bash
set -e
PATH=/usr/local/bin:${PATH}
cd /etc/kubernetes
/usr/bin/docker-compose --project-name kubernetes down

EOF
chmod +x /usr/local/bin/kubelet-daemon-stop

cat > /etc/systemd/system/kubelet.service <<EOF
[Unit]
Description=Kubernetes Kubelet Service
Documentation=https://docs.docker.com
After=network-online.target cloud-init.service chronyd.service docker.service
Requires=docker.service
Wants=network-online.target

[Service]
ExecStartPre=/usr/local/bin/kubelet-daemon-start
ExecStart=/usr/local/bin/kubelet-daemon-monitor
ExecStop=/usr/local/bin/kubelet-daemon-stop
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF




systemctl daemon-reload
systemctl restart kubelet






mkdir -p /etc/kubernetes/manifests
cat > /etc/kubernetes/manifests/kube-etcd.manifest <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: kube-etcd
spec:
  hostNetwork: true
  containers:
  - name: kube-etcd
    image: docker.io/port/system-etcd:latest
    command:
    - etcd
    - --name=bootstrap
    - --data-dir=/var/etcd
    - --listen-client-urls=http://localhost:2379,http://${HOST_ETCD_IP}:4001
    - --listen-peer-urls=http://${HOST_ETCD_IP}:7001
    - --advertise-client-urls=http://${HOST_ETCD_IP}:4001
    volumeMounts:
      - mountPath: /var/etcd
        name: var-etcd
  volumes:
    - name: "var-etcd"
      hostPath:
        path: "/var/etcd"
EOF


cat > /etc/network-environment <<EOF
# This host's IPv4 address (the source IP address used to reach other nodes
# in the Kubernetes cluster).
DEFAULT_IPV4=${HOST_CALICO_IP}

# IP and port of etcd instance used by Calico
ETCD_AUTHORITY=${HOST_ETCD_IP}:4001
EOF

cat > /etc/systemd/system/calico.service <<EOF
[Unit]
Description=Calico per-node agent
Documentation=https://github.com/projectcalico/calico-docker
Requires=docker.service
After=docker.service

[Service]
User=root
EnvironmentFile=/etc/network-environment
PermissionsStartOnly=true
ExecStart=/usr/bin/calicoctl node --ip=${HOST_CALICO_IP} --detach=false --node-image=docker.io/port/system-calico:latest
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF

systemctl restart calico









cat > /usr/local/bin/docker-swarm-daemon <<EOF
#!/bin/bash
set -e
PATH=/usr/local/bin:${PATH}
HOST_DOCKER_ADMIN_DEV=docker1
HOST_DOCKER_ADMIN_IP=\$(ip -f inet -o addr show \$HOST_DOCKER_ADMIN_DEV|cut -d\  -f 7 | cut -d/ -f 1)
HOST_ETCD_DEV=eth0
HOST_ETCD_IP=\$(ip -f inet -o addr show \$HOST_ETCD_DEV|cut -d\  -f 7 | cut -d/ -f 1)

docker stop swarm-node || true
docker kill swarm-node || true
docker rm -v swarm-node || true
exec docker run \
--name swarm-node \
docker.io/port/system-swarm:latest \
join \
--advertise=\${HOST_DOCKER_ADMIN_IP}:2375 \
etcd://\${HOST_ETCD_IP}:4001




EOF
chmod +x /usr/local/bin/docker-swarm-daemon

cat > /etc/systemd/system/docker-swarm.service <<EOF
[Unit]
Description=Docker Swarm Application Container Engine
Documentation=https://docs.docker.com
After=network-online.target cloud-init.service chronyd.service docker-wan.service
Requires=docker-wan.service
Wants=network-online.target

[Service]
ExecStart=/usr/local/bin/docker-swarm-daemon
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF




systemctl daemon-reload
systemctl restart docker-swarm




cat > /usr/local/bin/docker-swarm-manager-daemon <<EOF
#!/bin/bash
set -e
PATH=/usr/local/bin:${PATH}
HOST_DOCKER_ADMIN_DEV=docker1
HOST_DOCKER_ADMIN_IP=\$(ip -f inet -o addr show \$HOST_DOCKER_ADMIN_DEV|cut -d\  -f 7 | cut -d/ -f 1)
HOST_ETCD_DEV=eth0
HOST_ETCD_IP=\$(ip -f inet -o addr show \$HOST_ETCD_DEV|cut -d\  -f 7 | cut -d/ -f 1)

docker stop swarm-manger || true
docker kill swarm-manger || true
docker rm -v swarm-manger || true
exec docker run \
--name swarm-manger \
-p \${HOST_DOCKER_ADMIN_IP}:4000:2375 \
docker.io/port/system-swarm:latest manage --replication --advertise \${HOST_DOCKER_ADMIN_IP}:4000 etcd://\${HOST_ETCD_IP}:4001




EOF
chmod +x /usr/local/bin/docker-swarm-manager-daemon

cat > /etc/systemd/system/docker-swarm-manager.service <<EOF
[Unit]
Description=Docker Swarm Application Container Engine
Documentation=https://docs.docker.com
After=network-online.target cloud-init.service chronyd.service docker-wan.service
Requires=docker-wan.service
Wants=network-online.target

[Service]
ExecStart=/usr/local/bin/docker-swarm-manager-daemon
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF

cat > /usr/bin/swarm <<EOF
#!/bin/bash
HOST_DOCKER_ADMIN_DEV=docker1
HOST_DOCKER_ADMIN_IP=\$(ip -f inet -o addr show \$HOST_DOCKER_ADMIN_DEV|cut -d\  -f 7 | cut -d/ -f 1)

docker -H \${HOST_DOCKER_ADMIN_IP}:4000 "\$@"
EOF
chmod +x /usr/bin/swarm


systemctl daemon-reload
systemctl restart docker-swarm-manager



systemctl enable docker-bootstrap
systemctl enable skydns
systemctl enable openvswitch
systemctl enable flannel
systemctl enable docker-wan
systemctl enable docker
systemctl enable calico
systemctl enable docker-swarm
systemctl enable docker-swarm-manager



systemctl restart docker-bootstrap
systemctl restart skydns
systemctl restart openvswitch
systemctl restart flannel
systemctl restart docker-wan
systemctl restart docker
systemctl restart calico
systemctl restart kubelet
systemctl restart docker-swarm
systemctl restart docker-swarm-manager
systemctl status docker-swarm
systemctl status docker-swarm-manager








HOST_DOCKER_DEV=eth0
HOST_DOCKER_IP=$(ip -f inet -o addr show $HOST_DOCKER_DEV|cut -d\  -f 7 | cut -d/ -f 1)


HOST_CALICO_DEV=eth0
HOST_CALICO_IP=$(ip -f inet -o addr show $HOST_CALICO_DEV|cut -d\  -f 7 | cut -d/ -f 1)



HOST_ETCD_DEV=eth0
HOST_ETCD_IP=$(ip -f inet -o addr show $HOST_ETCD_DEV|cut -d\  -f 7 | cut -d/ -f 1)

HOST_KUBE_DEV=eth0
HOST_KUBE_IP=$(ip -f inet -o addr show $HOST_KUBE_DEV|cut -d\  -f 7 | cut -d/ -f 1)



calicoctl pool add 192.168.0.0/16 --nat-outgoing --ipip

HOST_FQDN="$(hostname -f)"

cat > /etc/kubernetes/manifests/kube-apiserver.manifest <<EOF
apiVersion: v1
kind: Pod
metadata:
  namespace: kube-system
  name: kube-apiserver
spec:
  containers:
  - name: kube-apiserver
    image: docker.io/port/system-kube:latest
    command:
    - /hyperkube
    - apiserver
    - --alsologtostderr=true
    - --bind-address=0.0.0.0
    - --v=2
    - --etcd_servers=http://${HOST_ETCD_IP}:4001
    - --insecure-bind-address=0.0.0.0
    - --insecure-port=8080
    - --allow_privileged=true
    - --service-cluster-ip-range=10.100.0.0/24
    - --service-node-port-range=22-30000
    - --runtime-config=extensions/v1beta1/daemonsets=true,extensions/v1beta1/jobs=true
EOF



cat > /etc/kubernetes/manifests/kube-controller-manager.manifest <<EOF
apiVersion: v1
kind: Pod
metadata:
  namespace: kube-system
  name: kube-controller-manager
spec:
  containers:
  - name: kube-controller-manager
    image: docker.io/port/system-kube:latest
    command:
    - /hyperkube
    - controller-manager
    - --alsologtostderr=true
    - --master=http://${HOST_KUBE_IP}:8080
EOF


cat > /etc/kubernetes/manifests/kube-scheduler.manifest <<EOF
apiVersion: v1
kind: Pod
metadata:
  namespace: kube-system
  name: kube-scheduler
spec:
  containers:
  - name: kube-scheduler
    image: docker.io/port/system-kube:latest
    command:
    - /hyperkube
    - scheduler
    - --alsologtostderr=true
    - --master=http://${HOST_KUBE_IP}:8080
EOF

cat > /etc/kubernetes/manifests/kube-proxy.manifest <<EOF
apiVersion: v1
kind: Pod
metadata:
  namespace: kube-system
  name: kube-proxy
spec:
  hostNetwork: true
  containers:
  - name: kube-proxy
    image: docker.io/port/system-kube:latest
    command:
    - /hyperkube
    - proxy
    - --proxy-mode=iptables
    - --alsologtostderr=true
    - --bind-address=0.0.0.0
    - --master=http://${HOST_KUBE_IP}:8080
    securityContext:
      privileged: true
EOF

kubectl get nodes
calicoctl status








mkdir -p /etc/kubernetes/applications
cat > /etc/kubernetes/applications/kube-dns.yaml <<EOF
apiVersion: v1
kind: Namespace
metadata:
  name: kube-system
---
apiVersion: v1
kind: ReplicationController
metadata:
  name: kube-dns
  namespace: kube-system
  labels:
    k8s-app: kube-dns
    kubernetes.io/cluster-service: "true"
spec:
  replicas: 2
  selector:
    k8s-app: kube-dns
  template:
    metadata:
      labels:
        k8s-app: kube-dns
        kubernetes.io/cluster-service: "true"
    spec:
      containers:
      - name: etcd
        image: docker.io/port/system-etcd:latest
        resources:
          limits:
            cpu: 100m
            memory: 50Mi
          requests:
            cpu: 100m
            memory: 50Mi
        command:
        - etcd
        - -data-dir
        - /var/etcd/data
        - -listen-client-urls
        - http://127.0.0.1:2379,http://127.0.0.1:4001
        - -advertise-client-urls
        - http://127.0.0.1:2379,http://127.0.0.1:4001
        - -initial-cluster-token
        - skydns-etcd
        volumeMounts:
        - name: etcd-storage
          mountPath: /var/etcd/data
      - name: kube2sky
        image: docker.io/port/system-kube2sky:latest
        imagePullPolicy: IfNotPresent
        resources:
          limits:
            cpu: 100m
            memory: 50Mi
        command:
        - /kube2sky
        - -domain=cluster.local
        - -kube_master_url=http://10.120.100.230:8080
      - name: skydns
        image: docker.io/port/system-skydns:latest
        imagePullPolicy: IfNotPresent
        resources:
          limits:
            cpu: 100m
            memory: 50Mi
        command:
        - /skydns
        - -machines=http://127.0.0.1:4001
        - -addr=0.0.0.0:53
        - -domain=cluster.local
        - -nameservers=8.8.8.8:53
        ports:
        - containerPort: 53
          name: dns
          protocol: UDP
        - containerPort: 53
          name: dns-tcp
          protocol: TCP
      volumes:
      - name: etcd-storage
        emptyDir: {}
      dnsPolicy: Default
---
apiVersion: v1
kind: Service
metadata:
  name: kube-dns
  namespace: kube-system
  labels:
    k8s-app: kube-dns
    kubernetes.io/cluster-service: "true"
    kubernetes.io/name: "KubeDNS"
spec:
  selector:
    k8s-app: kube-dns
  clusterIP: 10.100.0.2
  ports:
  - name: dns
    port: 53
    protocol: UDP
  - name: dns-tcp
    port: 53
    protocol: TCP
EOF
kubectl delete -f /etc/kubernetes/applications/kube-dns.yaml
kubectl create -f /etc/kubernetes/applications/kube-dns.yaml


kubectl run --image=nginx --replicas=1 nginx
swarm run -d nginx


IPA_DATA_DIR=/var/lib/harbor/freeipa/master

rm -rf /tmp/freeipa
mkdir -p /tmp/freeipa
echo "--allow-zone-overlap" >> ${IPA_DATA_DIR}/ipa-server-install-options
echo "--setup-dns" >> ${IPA_DATA_DIR}/ipa-server-install-options
echo "--forwarder=8.8.8.8" >> ${IPA_DATA_DIR}/ipa-server-install-options
echo "--forwarder=8.8.4.4" >> ${IPA_DATA_DIR}/ipa-server-install-options
for BRIDGE_IP in 192.168.0.0/16 10.100.0.0/24 10.98.0.0/16 10.96.0.0/15; do
  # do something
  REVERSE_ZONE=$(echo ${BRIDGE_IP} | awk -F. '{print $3"." $2"."$1".in-addr.arpa."}')
  echo "--reverse-zone=${REVERSE_ZONE}" >> ${IPA_DATA_DIR}/ipa-server-install-options
done
echo "--ds-password=Password123" >> ${IPA_DATA_DIR}/ipa-server-install-options
echo "--admin-password=Password123" >> ${IPA_DATA_DIR}/ipa-server-install-options


cat > /usr/local/bin/freeipa-master-daemon <<EOF
#!/bin/bash
set -e
IPA_DATA_DIR=/var/lib/harbor/freeipa/master
docker-wan stop freeipa-master || true
docker-wan kill freeipa-master || true
docker-wan rm -v freeipa-master || true
FREEIPA_MASTER_ID=\$(docker-wan run -t -d \\
 --hostname=freeipa-master.harboros.net \\
 --name=freeipa-master \\
 -v \$IPA_DATA_DIR:/data:rw \\
 -v /sys/fs/cgroup:/sys/fs/cgroup:ro \\
 --dns=8.8.8.8 \\
 -e OS_DOMAIN=harboros.net \\
 docker.io/port/ipa-server:latest)

FREEIPA_MASTER_IP=\$(docker-wan inspect --format '{{ .NetworkSettings.IPAddress }}' \${FREEIPA_MASTER_ID})

FREEIPA_MASTER_DNS_IP=\$(dig +short +time=1 +tries=20 freeipa-master.harboros.net @\$FREEIPA_MASTER_IP)
while [ -z "\$FREEIPA_MASTER_DNS_IP" ]; do
  echo "Waiting For FreeIPA DNS to respond"
  FREEIPA_MASTER_DNS_IP=\$(dig +short +time=1 +tries=20 freeipa-master.harboros.net @\$FREEIPA_MASTER_IP)
done

while [ "\$FREEIPA_MASTER_IP" != "\$FREEIPA_MASTER_DNS_IP" ]; do
  echo "Waiting for FreeIPA DNS to return expected IP"
  sleep 2s
  FREEIPA_MASTER_DNS_IP=\$(dig +short +time=1 +tries=20 freeipa-master.harboros.net @\${FREEIPA_MASTER_DNS_IP})
done

until etcdctl get /skydns/config; do
   echo "Waiting for ETCD"
   sleep 5
done
SKYDNS_CONFIG="{\\"dns_addr\\":\\"172.17.42.1:53\\", \\"ttl\\":3600, \\"nameservers\\": [\\"\${FREEIPA_MASTER_DNS_IP}:53\\"]}"
SKYDNS_CONFIG_ETCD="\$(etcdctl get /skydns/config)"

if [ "\${SKYDNS_CONFIG}" != "\${SKYDNS_CONFIG_ETCD}" ]; then
   etcdctl set /skydns/config "\${SKYDNS_CONFIG}"
fi

EOF
chmod +x /usr/local/bin/freeipa-master-daemon


cat > /etc/systemd/system/freeipa-master.service <<EOF
[Unit]
Description=FreeIPA Master Server
After=network-online.target cloud-init.service chronyd.service docker-wan.service
Requires=docker-wan.service
Wants=network-online.target

[Service]
ExecStartPre=/usr/local/bin/freeipa-master-daemon
ExecStart=/usr/bin/docker-wan wait freeipa-master
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF




systemctl daemon-reload
systemctl restart freeipa-master
